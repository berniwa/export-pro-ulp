/************************************************************/
/* HTLExportPro_CropColor.ulp                               */
/* - Beschneidet Color BMP Images                           */
/************************************************************/
/* (c) Copyright 2011, Bernhard Wörndl-Aichriedler          */
/* xDevelop OG - Hardware Developer			*/
/* E-Mail: bwa@berniwa.com (bwa@xdevelop.at)                */
/* Homepage: www.berniwa.com (www.xdevelop.at)              */
/************************************************************/
/* Die Verwendung, das Kopieren bzw. die Weiterverbreitung  */
/* dieses ULP sind nur nach ausdrücklicher Erlaubnis des    */
/* Autors gestattet! 				*/
/************************************************************/
/* Letzte Änderung am 23.02.2011                            */
/* Version 1.0 (in ExportPro6)                            	*/
/************************************************************/


int BMP_bfOffBits = 10;
int BMP_biWidth 	= 18;
int BMP_biHeight	= 22;
int BMP_colorTableFirst = 0x36;

char bmpData[];
int bmpOffset = 0;
int bmpWidth = 0;
int bmpHeight = 0;
int bmpBlockSize = 0;

int bmpReadInt(int offset)
{
	int value = 0;
			
	for(int i = 0; i < 4; i++) 
	{
		value |= bmpData[offset + i] << (i*8);
	}

	return value;	
}

void bmpWriteInt(int bmpInt)
{

	int value = 0;
		
	for(int i = 0; i < 4; i++) 
	{
		printf("%c", (bmpInt >> (8*i)) & 0x000000FF);
	}	
}

void bmpConvert(string ifilename)
{
	int bmpOffsetTop = 0, bmpOffsetLeft = -1, bmpOffsetRight = -1, bmpOffsetBottom = 0;
	int bmpOffsetTopDetected = 0, bmpOffsetBottomDetected = 0;
	int bmpZeroIsBlack = 0; 


	int nBytes = fileread(bmpData, ifilename);

  
  	/*
  		Read status information
  	*/
  	bmpOffset = bmpReadInt(BMP_bfOffBits);
  	bmpWidth = bmpReadInt(BMP_biWidth);
  	bmpHeight = bmpReadInt(BMP_biHeight);

	/*
		Check what color in the table is white and what is black
		Quick'n dirty
	*/
	bmpZeroIsBlack = (bmpData[BMP_colorTableFirst] == 0)?1:0;	

	/*
  		Calculate blocksize (24 bit RGB)
  	*/
	bmpBlockSize = ceil((24.0 * bmpWidth)/32.0)*4;


	string mstatus = "";
	sprintf(mstatus, "Cropping image: %s - Calculating cropping areas", ifilename);
	status(mstatus);

	int lastline_mask = (pow(2, (bmpWidth % 8)) - 1);
	int used_blocks = bmpWidth / 8;	

	/*
  		Walk thru - line by line
  	*/
  	for(int line = 0; line < bmpHeight; line++)
  	{
  		int offset = bmpOffset+line*bmpBlockSize;

		int bmpLineOffsetLeft = 0, bmpLineOffsetRight = 0;
		int bmpLineOffsetLeftDetected = 0, bmpLineOffsetRightDetected = 0;

  		for(int byte = 0; byte < bmpWidth; byte++)
  		{
			int dbyte = offset + byte*3;
			int is_black = bmpData[dbyte] == 0 && bmpData[dbyte+1] == 0 && bmpData[dbyte+2] == 0;

  			if(!is_black)
			{
				if(bmpLineOffsetLeftDetected == 0)
				{
					bmpLineOffsetLeft = byte;
				}
				if(bmpLineOffsetRightDetected == 0)
				{
					bmpLineOffsetRight = byte;
					bmpLineOffsetRightDetected = 1;
				}				
			}

			if(is_black && bmpLineOffsetLeftDetected == 0)
			{
				bmpLineOffsetLeftDetected = 1;
			}
			if(is_black && bmpLineOffsetRightDetected == 1)
			{
				bmpLineOffsetRightDetected = 0;
			}
  		}

		if(bmpLineOffsetLeftDetected == 0)
		{

			if(bmpOffsetTopDetected == 0)
			{
				bmpOffsetTop = line;
			}
			if(bmpOffsetBottomDetected == 0)
			{
				bmpOffsetBottom = line;
				bmpOffsetBottomDetected = 1;
			}
		}
		else
		{
			if(bmpOffsetTopDetected == 0)
			{
				bmpOffsetTopDetected = 1;
			}
			if(bmpOffsetBottomDetected == 1)
			{
				bmpOffsetBottomDetected = 0;				
			}
			if(bmpOffsetLeft == -1 || bmpLineOffsetLeft < bmpOffsetLeft)
			{
				bmpOffsetLeft = bmpLineOffsetLeft;
			}
			if(bmpOffsetRight == -1 || bmpLineOffsetRight > bmpOffsetRight)
			{
				bmpOffsetRight = bmpLineOffsetRight;
			}
		}	
  	}




  	/*
  		Calculate new Information
  	*/
	int cut = 5;

	bmpOffsetRight -= cut;
	bmpOffsetLeft += cut;
	bmpOffsetTop += cut;
	bmpOffsetBottom -= cut;

  	int bmpNewWidth = bmpOffsetRight - bmpOffsetLeft;
  	int bmpNewHeight = bmpOffsetBottom - bmpOffsetTop;

  	/*
  		Calculate blocksize
  	*/
  	int bmpNewBlockSize = ceil((24.0 * bmpNewWidth)/32.0)*4;
	
	output(ifilename, "wb")
	{	
  		string mstatus = "";
  		sprintf(mstatus, "Cropping image: %s - Loading image information", ifilename);
  		status(mstatus);
  		
  		//Copy header
  		for(int i = 0; i < bmpOffset; i++)
  		{
			if(i == BMP_biWidth)
			{
				//Write new width & height
				bmpWriteInt(bmpNewWidth);
				bmpWriteInt(bmpNewHeight);
				i+=7;	
			}
			else
			{
  				printf("%c", bmpData[i]);
			}	
  		}
  	
  		sprintf(mstatus, "Cropping image: %s - Copying image data", ifilename);
  		status(mstatus);
  
  		
  		//Walk thru - line by line
  		
  		for(int line = bmpOffsetTop; line < bmpOffsetBottom; line++)
  		{
  			int offset = bmpOffset+line*bmpBlockSize + bmpOffsetLeft*3;
  	
  			sprintf(mstatus, "Cropping image: %s - Finished %.0f%%", ifilename, (line*1.0/bmpHeight*100.0));
  			status(mstatus);
  			
			string xdata = "";
  			for(int byte = 0; byte < bmpNewBlockSize; byte++)
  			{
				xdata += bmpData[offset  + byte];
			}
			printf(xdata);	
  		}

	}
}


bmpConvert(argv[1]);
