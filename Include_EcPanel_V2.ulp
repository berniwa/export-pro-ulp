#include "Include_Boardsize.ulp"


void dbgMsg(string msg,real val){
	//to prevent debug messages to apear in releace
	string tmp="";
	sprintf(tmp,msg+"%f",val);
	dlgMessageBox(tmp);
}

real wireX1[];
real wireY1[];
real wireX2[];
real wireY2[];
real wireRad[];

int wireCount=0;
int clockwise=0;

int gapWidth = 2; //distance between board and panel inline in mm
int panelMinWidthX = 7, panelMinWidthY = 6; //min distance between board and panel outline in mm 

int infinety = 1000000000;	//since the max board size is 338 x 238, 1000000000 is aproximatly infinety

string cmd = "";

void reverseDirection(int index){
	wireX2[index] = wireX2[index] + wireX1[index];
	wireX1[index] = wireX2[index] - wireX1[index];
	wireX2[index] = wireX2[index] - wireX1[index];

	wireY2[index] = wireY2[index] + wireY1[index];
	wireY1[index] = wireY2[index] - wireY1[index];
	wireY2[index] = wireY2[index] - wireY1[index];

	wireRad[index]*=-1;
}

void swopPlaces(int index1, int index2){
	real tmp;

	tmp				= wireX1[index1];
	wireX1[index1] 	= wireX1[index2];
	wireX1[index2] 	= tmp;

	tmp				= wireY1[index1];
	wireY1[index1] 	= wireY1[index2];
	wireY1[index2] 	= tmp;

	tmp				= wireX2[index1];
	wireX2[index1] 	= wireX2[index2];
	wireX2[index2] 	= tmp;

	tmp				= wireY2[index1];
	wireY2[index1] 	= wireY2[index2];
	wireY2[index2] 	= tmp;

	tmp 			= wireRad[index1];
	wireRad[index1] = wireRad[index2];
	wireRad[index2] = tmp;
}

void main(){
	getBoardSize();

	real maxX = u2mm(max_x);
	real minX = u2mm(min_x);
	real maxY = u2mm(max_y);
	real minY = u2mm(min_y);

	real lenX = maxX-minX;
	real lenY = maxY-minY;

	real centerX = minX+(lenX/2);
	real centerY = minY+(lenY/2);

	sprintf(cmd, "WRITE;\n");

	/*Check, if board fits in, if not, return Error message and don't run rest of ulp/create frame and stencil*/

	if(lenX > 338 || lenX < 38 || lenY > 238 || lenY < 38){

	   dlgMessageBox(":Error!\nUnable to export panel\nBoard Size must be within: \n\n" + "x: 38mm - 338mm" + "\n" + "y: 38mm - 238mm"); 

	   exit(0);
	}

	//saving the board-dimensions within an array
	board(B){
		int i=0;
		B.wires(W){
			if(W.layer == 20){
				wireX1[i]=u2mm(W.x1);
				wireY1[i]=u2mm(W.y1);
				wireX2[i]=u2mm(W.x2);
				wireY2[i]=u2mm(W.y2);

				if(W.arc){
					wireRad[i]=(W.arc.radius/320000);//to convert to mm
				}
				else{
					wireRad[i]=0;
				}
				i++;
			}
		}
		wireCount=i;
	}

	//debugging
	output("W:/Tobias/tmp/dbgOut1.txt"){
		for (int i = 0; i < wireCount; i++)
		{
			if(wireRad[i]){
				printf("Wire%d is ARC, starts at (%f %f), ends with (%f %f), at an radius %f \n",i,wireX1[i],wireY1[i],wireX2[i],wireY2[i],wireRad[i]);
			} else {
				printf("Wire%d starts at (%f %f) ends with (%f %f)\n",i,wireX1[i],wireY1[i],wireX2[i],wireY2[i]);
			}
		}
	}

	clockwise=0;
	//sorting the board-dimensions
	for(int i=1; i<wireCount; i++){
		if((wireX1[i]==wireX2[i-1])&&(wireY1[i]==wireY2[i-1])){
		}
		else if ((wireX2[i]==wireX2[i-1])&&(wireY2[i]==wireY2[i-1])){
			//reversing the direction of the wire so every wire either gos clockwise or counterclockwise
			reverseDirection(i);
		}
		else{
			for(int j=i+1;j<wireCount;j++){
				if((wireX1[j]==wireX2[i-1])&&(wireY1[j]==wireY2[i-1])){
					swopPlaces(i,j);
					break;
				}
				else if((wireX2[j]==wireX2[i-1])&&(wireY2[j]==wireY2[i-1])){
					swopPlaces(i,j);

					//reversing the direction of the wire so every wire either gos clockwise or counterclockwise
					reverseDirection(i);

					break;
				}
			}
		}
	
		//determerning wire direction
		if((wireX1[i]>centerX)&&(wireX2[i]>centerX)&&(wireY1[i]>centerY)&&(wireY2[i]>centerY)) {
			//I
			if((wireX1[i]>wireX2[i])||(wireY1[i]<wireY2[i])) {
				clockwise++;
			}
			else {
				clockwise--;
			}
		}
		else if((wireX1[i]<centerX)&&(wireX2[i]<centerX)&&(wireY1[i]>centerY)&&(wireY2[i]>centerY)) {
			//II
			if((wireX1[i]>wireX2[i])||(wireY1[i]>wireY2[i])) {
				clockwise++;
			}
			else {
				clockwise--;
			}
		}
		else if((wireX1[i]<centerX)&&(wireX2[i]<centerX)&&(wireY1[i]<centerY)&&(wireY2[i]<centerY)) {
			//III
			if((wireX1[i]<wireX2[i])||(wireY1[i]>wireY2[i])) {
				clockwise++;
			}
			else {
				clockwise--;
			}
		}
		else if((wireX1[i]>centerX)&&(wireX2[i]>centerX)&&(wireY1[i]<centerY)&&(wireY2[i]<centerY)) {
			//IV
			if((wireX1[i]<wireX2[i])||(wireY1[i]<wireY2[i])) {
				clockwise++;
			}
			else {
				clockwise--;
			}
		}
		else if((wireY1[i]>centerY)&&(wireY2[i]>centerY)) {
			//I&II
			if(wireX1[i]>wireX2[i]) {
				clockwise++;
			}
			else {
				clockwise--;
			}
		}
		else if((wireX1[i]<centerX)&&(wireX2[i]<centerX)) {
			//II&III
			if(wireY1[i]>wireY2[i]) {
				clockwise++;
			}
			else {
				clockwise--;
			}
		}
		else if((wireY1[i]<centerY)&&(wireY2[i]<centerY)) {
			//III&IV
			if(wireX1[i]<wireX2[i]) {
				clockwise++;
			}
			else {
				clockwise--;
			}
		}
		else if((wireX1[i]>centerX)&&(wireX2[i]>centerX)) {
			//IV&I
			if(wireY1[i]<wireY2[i]) {
				clockwise++;
			}
			else {
				clockwise--;
			}
		}
	}

	if(clockwise>0){
		clockwise=1;
	}
	else if(clockwise<0){
		clockwise=-1;
	}
	else{
		dlgMessageBox("Unable to produce a panel");
		exit("");
	}

	//debugging

	output("W:/Tobias/tmp/dbgOut2.txt"){
		printf("clockwise=%d\n",clockwise );
		for (int i = 0; i < wireCount; i++)
		{
			if(wireRad[i]){
				printf("Wire%d is ARC, starts at (%f %f), ends with (%f %f), at an radius %f \n",i,wireX1[i],wireY1[i],wireX2[i],wireY2[i],wireRad[i]);
			} else {
				printf("Wire%d starts at (%f %f) ends with (%f %f)\n",i,wireX1[i],wireY1[i],wireX2[i],wireY2[i]);
			}
		}
	}

	//start writing the script
	cmd = "";

	sprintf(cmd, "%s DISPLAY NONE;\n", cmd);

	sprintf(cmd, "%s SET CONFIRM YES;\n", cmd);
	sprintf(cmd, "%s LAYER DIMENSION;\n", cmd);
	sprintf(cmd, "%s CHANGE WIDTH 0.15mm;\n", cmd);

	sprintf(cmd, "%s GROUP ALL;\n", cmd);
	sprintf(cmd, "%s CHANGE WIDTH 0.15mm (>0 0);\n", cmd);
	sprintf(cmd, "%s SET WIRE_BEND 2;\n", cmd);

	//crearing the panel-outline
	real x_min_outline = minX-panelMinWidthX;
	real x_max_outline = maxX+panelMinWidthX;
	real y_min_outline = minY-panelMinWidthY;
	real y_max_outline = maxY+panelMinWidthY;

	sprintf(cmd, "%s WIRE 'outline_panel' (%fmm %fmm) (%fmm %fmm) (%fmm %fmm) (%fmm %fmm) (%fmm %fmm);\n", cmd, x_min_outline, y_min_outline, x_max_outline, y_min_outline, x_max_outline, y_max_outline, x_min_outline, y_max_outline, x_min_outline, y_min_outline);

	//creating the panel-inline 
	real drawX=0, drawY=0, oriX=0, oriY=0, tmpX=0, tmpY=0, drawR=0;

	for(int n=0;n<wireCount;n++){
		drawR=1;

		//seting the start point
		
		if(n==0){ 
			if(wireRad[n]){

				drawX=wireX1[n];
				drawY=wireY1[n];

				if(clockwise>0){
					if(wireRad[n]>0){
						if((wireX1[n]>wireX2[n])&&(wireY1[n]>wireY2[n])){
							
							drawY+=gapWidth;
						}
						else if((wireX1[n]>wireX2[n])&&(wireY1[n]<wireY2[n])){
							drawX+=gapWidth;
							
						}
						else if((wireX1[n]<wireX2[n])&&(wireY1[n]>wireY2[n])){
							drawX-=gapWidth;
						}
						else {
							drawY-=gapWidth;
						}
					}
					else{
						if((wireX1[n]>wireX2[n])&&(wireY1[n]>wireY2[n])){
							drawX+=gapWidth;
						}
						else if((wireX1[n]>wireX2[n])&&(wireY1[n]<wireY2[n])){
							drawY+=gapWidth;
						}
						else if((wireX1[n]<wireX2[n])&&(wireY1[n]>wireY2[n])){
							drawY-=gapWidth;
						}
						else {
							drawX+=gapWidth;
						}
					}
				}
				else{
					if(wireRad[n]>0){
						if((wireX1[n]>wireX2[n])&&(wireY1[n]>wireY2[n])){
							drawX+=gapWidth;
						}
						else if((wireX1[n]>wireX2[n])&&(wireY1[n]<wireY2[n])){
							drawY-=gapWidth;
						}
						else if((wireX1[n]<wireX2[n])&&(wireY1[n]>wireY2[n])){
							drawY+=gapWidth;
						}
						else {
							drawX-=gapWidth;
						}
					}
					else{
						if((wireX1[n]>wireX2[n])&&(wireY1[n]>wireY2[n])){
							drawY-=gapWidth;
						}
						else if((wireX1[n]>wireX2[n])&&(wireY1[n]<wireY2[n])){
							drawX-=gapWidth;
						}
						else if((wireX1[n]<wireX2[n])&&(wireY1[n]>wireY2[n])){
							drawX+=gapWidth;
						}
						else {
							drawY+=gapWidth;
						}
					}
				}
			}
			else{
				//creating a normal vector and storing the signs
				tmpX = clockwise*(wireY2[n]-wireY1[n]);
				tmpY = (-1)*clockwise*(wireX2[n]-wireX1[n]);
				//to prvent a dividing by 0 error
				if(tmpX==0){
					drawX=0;
					drawY=(clockwise*gapWidth)*(tmpY/abs(tmpY));
				}
				else if (tmpY==0) {
					drawX=(clockwise*gapWidth)*(tmpX/abs(tmpX));
					drawY=0;
				} 
				else{
					//triming the vector and unsigning
					drawX=gapWidth*cos(atan(abs(tmpY/tmpX)));
					drawX=gapWidth*sin(atan(abs(tmpY/tmpX)));
					//resigning the normal vector
					drawX*=tmpX/abs(tmpX);
					drawY*=tmpY/abs(tmpY);
				}
				//ading the normal vector to the position vector
				drawX+=wireX1[n];
				drawY+=wireY1[n];
			}
			oriX=drawX;
			oriY=drawY;
			sprintf(cmd,"%sWIRE 'inline_panel' (%fmm %fmm)",cmd,drawX,drawY);
		}

		//seting endpoints 
		
		if(wireRad[n]){//drawing an arc
			//getting the radius right
			drawR=wireRad[n];
			drawR+=(clockwise*gapWidth);

			if(drawR<0){
				sprintf(cmd,"%s @%f ",cmd,drawR);
			}
			else{
				sprintf(cmd,"%s @+%f",cmd,drawR);
			}

			//seting the end coordinates
			drawX=wireX2[n];
			drawY=wireY2[n];

			//Ajusting end coordinats
			if(clockwise>0){
				if (wireRad[n]>0) {
					if((wireX1[n]>wireX2[n])&&(wireY1[n]>wireY2[n])){
						//dbgMsg("x- y- c:",n);
						drawX-=gapWidth;
					}
					else if((wireX1[n]>wireX2[n])&&(wireY1[n]<wireY2[n])){
						//dbgMsg("x- y+ c:",n);
						drawY+=gapWidth;
					}
					else if((wireX1[n]<wireX2[n])&&(wireY1[n]>wireY2[n])){
						//dbgMsg("x+ y- c:",n);
						drawY-=gapWidth;
					}
					else {
						//dbgMsg("x+ y+ c:",n);
						drawX+=gapWidth;
					}
				}
				else {
					if((wireX1[n]>wireX2[n])&&(wireY1[n]>wireY2[n])){
						//dbgMsg("x- y- c:",n);
						drawY+=gapWidth;
					}
					else if((wireX1[n]>wireX2[n])&&(wireY1[n]<wireY2[n])){
						//dbgMsg("x- y+ c:",n);
						drawX+=gapWidth;
					}
					else if((wireX1[n]<wireX2[n])&&(wireY1[n]>wireY2[n])){
						//dbgMsg("x+ y- c:",n);
						drawX-=gapWidth;
					}
					else {
						//dbgMsg("x+ y+ c:",n);
						drawY-=gapWidth;
					}
				}
			}
			else{
				if (wireRad[n]>0) {
					if((wireX1[n]>wireX2[n])&&(wireY1[n]>wireY2[n])){
						//dbgMsg("x- y- c!:",n);
						drawY-=gapWidth;
					}
					else if((wireX1[n]>wireX2[n])&&(wireY1[n]<wireY2[n])){
						//dbgMsg("x- y+ c!:",n);
						drawX-=gapWidth;
					}
					else if((wireX1[n]<wireX2[n])&&(wireY1[n]>wireY2[n])){
						//dbgMsg("x+ y- c!:",n);
						drawX+=gapWidth;
					}
					else {
						//dbgMsg("x+ y+ c!:",n);
						drawY+=gapWidth;
					}
				}
				else {
					if((wireX1[n]>wireX2[n])&&(wireY1[n]>wireY2[n])){
						//dbgMsg("x- y- c!:",n);
						drawX+=gapWidth;
					}
					else if((wireX1[n]>wireX2[n])&&(wireY1[n]<wireY2[n])){
						//dbgMsg("x- y+ c!:",n);
						drawY-=gapWidth;
					}
					else if((wireX1[n]<wireX2[n])&&(wireY1[n]>wireY2[n])){
						//dbgMsg("x+ y- c!:",n);
						drawY+=gapWidth;
					}
					else {
						//dbgMsg("x+ y+ c!:",n);
						drawX-=gapWidth;
					}
				}
			}
		}
		else {//drawing lines
			//creating a normal vector and storing the signs
			tmpX = clockwise*(wireY2[n]-wireY1[n]);
			tmpY = -1*clockwise*(wireX2[n]-wireX1[n]);
			//to prvent a dividing by 0 error
			if(tmpX==0){
				drawX=0;
				drawY=(clockwise*gapWidth)*(tmpY/abs(tmpY));
			}
			else if (tmpY==0) {
				drawX=(clockwise*gapWidth)*(tmpX/abs(tmpX));
				drawY=0;
			} 
			else{
				//triming the vector and unsigning
				drawX=gapWidth*cos(atan(abs(tmpY/tmpX)));
				drawY=gapWidth*sin(atan(abs(tmpY/tmpX)));
				//resigning the normal vector
				drawX*=tmpX/abs(tmpX);
				drawY*=tmpY/abs(tmpY);
			}
			//ading the normal vector to the position vector
			drawX+=wireX2[n];
			drawY+=wireY2[n];


			if(!wireRad[n+1]){
				//calculating the next line within polarform
				real drawX1=0, drawY1=0, tmpX1=0, tmpY1=0;

				tmpX1 = clockwise*(wireY2[n+1]-wireY1[n+1]);
				tmpY1 = (-1)*clockwise*(wireX2[n+1]-wireX1[n+1]);
				//to prvent a dividing by 0 error
				if(tmpX1==0){
					drawX1=0;
					drawY1=(clockwise*gapWidth)*(tmpY1/abs(tmpY1));
				}
				else if (tmpY1==0) {
					drawX1=(clockwise*gapWidth)*(tmpX1/abs(tmpX1));
					drawY1=0;
				} 
				else{
					//triming the vector and unsigning
					drawX1=gapWidth*cos(atan(abs(tmpY1/tmpX1)));
					drawY1=gapWidth*sin(atan(abs(tmpY1/tmpX1)));
					//resigning the normal vector
					drawX1*=tmpX/abs(tmpX1);
					drawY1*=tmpY/abs(tmpY1);
				}
				//ading the normal vector to the position vector
				drawX1+=wireX1[n+1];
				drawY1+=wireY1[n+1];

				tmpX = (wireX2[n]-wireX1[n]);
				tmpY = (wireY2[n]-wireY1[n]);
				tmpX1 = (wireX2[n+1]-wireX1[n+1]);
				tmpY1 = (wireY2[n+1]-wireY1[n+1]);

				//converting the polarforms into linear functions (y=k*x+d)
				//from here on out tmpX==k, tmpY==d, tmpX1==k1 & tmpY1==d1

				//calculating k & k1
				if((tmpX==0) && (tmpX1==0)){
					tmpX=infinety;		
					tmpX1=infinety;
				} 
				else if(tmpX==0) {
					tmpX=infinety;
					tmpX1=tmpY1/tmpX1;
				}
				else if(tmpX1==0) {
					tmpX=tmpY/tmpX;
					tmpX1=infinety;
				}
				else{
					tmpX=tmpY/tmpX;
					tmpX1=tmpY1/tmpX1;
				}

				//calculating d & d1
				tmpY=drawY-(drawX*tmpX);
				tmpY1=drawY1-(drawX1*tmpX1);

				//calculating the point of interception
				drawX=(tmpY1-tmpY)/(tmpX-tmpX1);
				drawY=tmpX*drawX+tmpY;
			}
		}

		if(drawR!=0){ //to prvent clicking the same point twice
			sprintf(cmd,"%s (%fmm %fmm)\n",cmd,drawX,drawY);
		}
	}
	//to close the ring and to end the wire comand
	sprintf(cmd,"%s (%f %f);\n",cmd,oriX,oriY);
	

	//Creating a Bridg package
	cmd+="OPEN fabrication.lbr;\n";
	cmd+="SET CONFIRM YES;\n";
	cmd+="EDIT bridg.pac;\n";
	cmd+="CHANGE WIDTH 0.15mm;\n";
	cmd+="LAYER DIMENSION;\n";
	cmd+="GRID mm 0.1;\n";
	cmd+="SET WIRE_BEND 2;\n";

	//Drawing the bridge
	cmd+="arc cw (1.5mm 0mm) (1.5mm 2mm) (1.5mm 2mm);\n";
	cmd+="arc ccw (-1.5mm 0mm) (-1.5mm 2mm) (-1.5mm 2mm);\n";

	//Drill holes
	cmd+="CHANGE DRILL 0.35mm;\n";

	for(real d=-1.5;d<2;d+=0.5){
		sprintf(cmd,"%sHOLE (%fmm 0mm);\n",cmd,d);
	}
	//saving library 
	cmd+="WRITE 'fabrication.lbr';\n";
	cmd+="CLOSE 'fabrication.lbr';\n"; //WHY DOES THIS NOT WORK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	cmd+="USE 'fabrication.lbr';\n";

	//TODO: Adding bridges
	output("W:/Tobias/tmp/tmp.scr"){
		printf("%s",cmd);
	}

	exit(cmd);
}

//main();
