#usage  "<b>Via Fill v0.1</b><p>"
	"Fills any polygons connected to specified nets."
       "<p>"
       "With a grid of vias, if there is a corresponding polygon on the other side"
       "of the board. Rectiliar or staggered grid can be chosen.<p>"
	"Specify via spacing, grid type, nets (by pick list) <p>"
	"Creates viapos.scr when can be run on a PCB to add vias, and viaposundo.scr "
	"which undos a run of the viapos.scr script. Note the viaposundo.scr should only be "
	"immediately after running the viapos.scr script, it only has undo statements in it and might accidentally "
	"undo actual operations if it is run otherwise<p>"
	"<p>Known Bugs:<p>"
	"-Will sometimes place vias on or near pads. User should check manually any cooincident vias/pads<p>"
	"-Position of via from edge of polygon depends on the filling width. Sometimes a via can extend past the"
	"polygon if the filling is very thin<p>"
	"-Doesn't differentiate between top/bottom/internal layers. It will place a via between the first two signal"
	"layers it finds<p>"
       "<author>Author: rgbphil@rgbsunset.com</author>"

// THIS PROGRAM IS PROVIDED AS IS AND WITHOUT WARRANTY OF ANY KIND, EXPRESSED OR IMPLIED

int cViaDiameter		= mm2u(0.3);	//Default via diameter in mm
int cViaSpacing		= mil2u(200);	//Default spacing in mil
int cViaIsolate		= mm2u(0.3);	//Restrict all vias in that area around an existing via or drill


real nViaSpacing 		= 0;
real nViaDiameter 	= 0;
real nViaIsolate		= 0;

int  niViaSpacing		= 0;
int  niViaDiameter	= 0;
int  niViaIsolate		= 0;

string sWidth;
string sHeight;
string sPCBdim;
string sSCHdim;

int pcb_grid_type;

//List of filling segments on defined nets
int nXSegStart[];
int nYSegStart[];
int nXSegEnd[];
int nYSegEnd[];
int nSegLayers[];
string sSegSignal[];
int nSegWidth[];

//List that is filled with restricted areas for vias
int nViaOrDrillX[];
int nViaOrDrillY[];
int nViaOrDrillDiameter[];
int nViaOrDrillLength = 0;

real xpos, ypos;
int xsize,ysize;
real nXOrigin, nYOrigin;
numeric string sPolygonNets[];
numeric string sSelectedNets[];
int nNumSegs;


/***********************************************************************************
 * This function return the internal coordinates to be used within this up
 * @param	n	position in mic,mm, mil or inch
 * @return		Position in u
 ***********************************************************************************/
int internalPosition(real n)
{
	int retval;
	switch(pcb_grid_type)
	{
		case GRID_UNIT_MIC:
			retval = mic2u(n);
		break;
		case GRID_UNIT_MM:
			retval = mm2u(n);
		break;
		case GRID_UNIT_MIL:
			retval = mil2u(n);
		break;
		case GRID_UNIT_INCH:
			retval = inch2u(n);
		break;
	}
	return retval;
}

/***********************************************************************************
 * This function return the real pcb coordinates to be used in an outside script
 * it automatically converts u in the currently used grid
 * @param	n	position in u
 * @return		Position in mic,mm, mil or inch
 ***********************************************************************************/
real pcbPosition(int n)
{
	real retval;
	switch(pcb_grid_type)
	{
		case GRID_UNIT_MIC:
			retval = u2mic(n);
		break;
		case GRID_UNIT_MM:
			retval = u2mm(n);
		break;
		case GRID_UNIT_MIL:
			retval = u2mil(n);
		break;
		case GRID_UNIT_INCH:
			retval = u2inch(n);
		break;
	}
	return retval;
}


/***********************************************************************************
 * This function checks for collisions with vias or drill of the board, 
 * it will make sure, that no stitching via will come close to anything else
 * @param	x	X position of the via or drill
 * @param	y	Y Position of the via or drill
 * @param	diameter	Diameter of the hole or the entire via
 ***********************************************************************************/
void AddViaToList(int x, int y, int diameter)
{
	nViaOrDrillX[nViaOrDrillLength] 			= x;
	nViaOrDrillY[nViaOrDrillLength] 			= y;
	nViaOrDrillDiameter[nViaOrDrillLength] 		= diameter;

	nViaOrDrillLength ++;
}


//-------------------------------------------------------------------------------------
void GetDesignInfo()
{
	int i;
	int maxX = 0;
	int minX = 0;
	int maxY = 0; 
	int minY = 0;
	int initialized = 0;

	//get some units
	project.board(B)
	{
		pcb_grid_type = B.grid.unit;
	}

	switch(pcb_grid_type)
	{
		case GRID_UNIT_MIC:
			sPCBdim = "microns";
			break;
		case GRID_UNIT_MM:
			sPCBdim = "mm";
			break;
		case GRID_UNIT_MIL:
			sPCBdim = "mil";
			break;
		case GRID_UNIT_INCH:
			sPCBdim = "inch";
	}

	nViaSpacing 	= pcbPosition(cViaSpacing);
	nViaDiameter 	= pcbPosition(cViaDiameter);
	nViaIsolate	= pcbPosition(cViaIsolate);
	niViaSpacing 	= cViaSpacing;
	niViaDiameter 	= cViaDiameter;
	niViaIsolate	= cViaIsolate;

	//find all nets with polygons attached
	project.board(B)
	{
		B.signals(S)
		{
			S.polygons(P)
			{
				sPolygonNets[i] = S.name;
				i++;
				break;
			}
		}

		B.signals(S) {
			S.vias(V) {
				AddViaToList(V.x, V.y, V.diameter[LAYER_TOP]);
			}
		}
		
		B.holes(H)
		{
			AddViaToList(H.x, H.y, H.drill);
		}

		B.elements(E)
		{
			E.package.holes(H)
			{
				AddViaToList(H.x, H.y, H.drill);	
			}
			E.package.contacts(C)
			{
				if(C.pad)
				{
					AddViaToList(C.pad.x, C.pad.y, C.pad.diameter[LAYER_TOP]);
				}
			}
		
		}

		//Check dimension layer for board outlines
 		B.wires(W) 
		{
			if(W.layer == 20)
			{
				//Get max X and max Y coordinates
				//Arcs will not work, only square boards will work properly
				if(initialized == 0)
				{
					maxX =  W.x2;
					maxY =  W.y2;
					minX =  W.x1;
					minY =  W.y1;
					initialized = 1;
				}
				if(W.x2 > maxX) { maxX = W.x2;}
				if(W.y2 > maxY) { maxY = W.y2;}
				if(W.x1 < minX) { minX = W.x1;}
				if(W.y1 < minY) { minY = W.y1;}
			}
		}

		nXOrigin = int(minX/niViaSpacing) * niViaSpacing;
		nYOrigin = int(minY/ niViaSpacing) * niViaSpacing;
		xsize = (maxX - minX) / niViaSpacing;
		ysize = (maxY - minY) / niViaSpacing;
	}
	

}


/***********************************************************************************
 * This function checks for collisions with vias or drill of the board, 
 * it will make sure, that no stitching via will come close to anything else
 * @param	xp	X Position of the stitching via to be checked
 * @param	yp	Y Position of the stitching via to be checked
 * @return 		0 if a via collision has been detected, 1 if there is no collision
 ***********************************************************************************/
int CheckViaCollision(int x, int y)
{
	int i = 0;
	
	for(i = 0; i < nViaOrDrillLength; i++)
	{
		if( 	(x > nViaOrDrillX[i] - (nViaOrDrillDiameter[i] + niViaIsolate + niViaDiameter)) &&
			(x < nViaOrDrillX[i] + (nViaOrDrillDiameter[i] + niViaIsolate + niViaDiameter)) &&
			(y > nViaOrDrillY[i] - (nViaOrDrillDiameter[i] + niViaIsolate + niViaDiameter)) &&
			(y < nViaOrDrillY[i] + (nViaOrDrillDiameter[i] + niViaIsolate + niViaDiameter))
		  )
		{
			return 0;
		}
	}
	return 1;
}

/***********************************************************************************
 * This function returns true if the point XP,YP is located within width/2 of the line
 * ASSUMES segment of line (x1 y1)(x2 y2) is either horizontal or vertical so is only
 * really useful for use with the 'fillings' member of a polygon
 * NOTE that X1,Y1,X2,Y2,width are given in system coordinates (ie integers)
 * whilst the XP,YP point is given in board coordinates (ie a real mm,inch,micron,mil)
 * @return 		1 if on a segment, 0 if not
 ***********************************************************************************/
int IsOnSeg(int X1, int Y1, int X2, int Y2, int XP, int YP, int width)
{
	real nDistanceFromLine;
	int nWidth;
	int nX,nY;
	int nX1,nY1;
	int nX2, nY2;

	nWidth = width;
	nX1 = X1;
	nY1 = Y2;
	nX2 = X2;
	nY2 = Y2;

	if(X1==X2)
	{
		
		//is a vertical line
		//check for out of bounds
		if(Y2>Y1)
		{
			if ((nY2+nWidth)<YP) return 0;	//too far from top
			if ((nY1-nWidth)>YP) return 0;	//too far from bottom
			if (nY2<YP)
			{
				//point between top of segment and arc of fill
				nX = nX2;
				nY = nY2;
				nDistanceFromLine = sqrt(u2mil(XP-nX)*u2mil(XP-nX)+u2mil(YP-nY)*u2mil(YP-nY));
				//printf("Distance: %f allowed %f\n", nDistanceFromLine, u2mil(int(nWidth/2.0)));
				if (nDistanceFromLine<=u2mil(int(nWidth/2.0)))
					return 1;
				else
					return 0;
			}
			else if(nY1>YP)
			{
				//point between bottom of segment and arc of fill
				nX = nX1;
				nY = nY1;
				nDistanceFromLine = sqrt(u2mil(XP-nX)*u2mil(XP-nX)+u2mil(YP-nY)*u2mil(YP-nY));
				//printf("Distance: %f allowed %f\n", nDistanceFromLine, u2mil(int(nWidth/2.0)));
				if (nDistanceFromLine<=u2mil(int(nWidth/2.0)))
					return 1;
				else
					return 0;
			}
		}
		else
		{
			if ((nY1+nWidth)<YP) return 0;	//too far from top
			if ((nY2-nWidth)>YP) return 0;	//too far from bottom
			if (nY1<YP)
			{
				//point between top of segment and arc of fill
				nX = nX1;
				nY = nY1;
				nDistanceFromLine = sqrt(u2mil(XP-nX)*u2mil(XP-nX)+u2mil(YP-nY)*u2mil(YP-nY));
				//printf("Distance: %f allowed %f\n", nDistanceFromLine, u2mil(int(nWidth/2.0)));
				if (nDistanceFromLine<=u2mil(int(nWidth/2.0)))
					return 1;	//in range of the circle
				else
					return 0;
			}
			else if(nY2>YP)
			{
				//point between bottom of segment and arc of fill
				nX = nX2;
				nY = nY2;
				nDistanceFromLine = sqrt(u2mil(XP-nX)*u2mil(XP-nX)+u2mil(YP-nY)*u2mil(YP-nY));
				//printf("Distance: %f allowed %f\n", nDistanceFromLine, u2mil(int(nWidth/2.0)));
				if (nDistanceFromLine<=u2mil(int(nWidth/2.0)))
					return 1;
				else
					return 0;
			}		
		}


		//point is within top and bottom of segment
		if(abs(XP-nX1)>nWidth/2)
			return 0;
		else
			return 1;
		
	}
	else if(Y1==Y2)
	{
		//is a horizontal line
		if(X2>X1)
		{
			if ((nX2+nWidth)<XP) return 0;	//too far from top
			if ((nX1-nWidth)>XP) return 0;	//too far from bottom
			if (nX2<XP)
			{
				//point between top of segment and arc of fill
				nX = nX2;
				nY = nX2;
				nDistanceFromLine = sqrt(u2mil(XP-nX)*u2mil(XP-nX)+u2mil(YP-nY)*u2mil(YP-nY));
				//printf("Distance: %f allowed %f\n", nDistanceFromLine, u2mil(int(nWidth/2.0)));
				if (nDistanceFromLine<=u2mil(int(nWidth/2.0)))
					return 1;
				else
					return 0;
			}
			else if(nX1>XP)
			{
				//point between bottom of segment and arc of fill
				nX = nX1;
				nY = nY1;
				nDistanceFromLine = sqrt(u2mil(XP-nX)*u2mil(XP-nX)+u2mil(YP-nY)*u2mil(YP-nY));
				//printf("Distance: %f allowed %f\n", nDistanceFromLine, u2mil(int(nWidth/2.0)));
				if (nDistanceFromLine<=u2mil(int(nWidth/2.0)))
					return 1;
				else
					return 0;
			}
		}
		else
		{
			if ((nX1+nWidth)<XP) return 0;	//too far from top
			if ((nX2-nWidth)>XP) return 0;	//too far from bottom
			if (nX1<XP)
			{
				//point between top of segment and arc of fill
				nX = nX1;
				nY = nY1;
				nDistanceFromLine = sqrt(u2mil(XP-nX)*u2mil(XP-nX)+u2mil(YP-nY)*u2mil(YP-nY));
				//printf("Distance: %f allowed %f\n", nDistanceFromLine, u2mil(int(nWidth/2.0)));
				if (nDistanceFromLine<=u2mil(int(nWidth/2.0)))
					return 1;	//in range of the circle
				else
					return 0;
			}
			else if(nX2>XP)
			{
				//point between bottom of segment and arc of fill
				nX = nX2;
				nY = nY2;
				nDistanceFromLine = sqrt(u2mil(XP-nX)*u2mil(XP-nX)+u2mil(YP-nY)*u2mil(YP-nY));
				//printf("Distance: %f allowed %f\n", nDistanceFromLine, u2mil(int(nWidth/2.0)));
				if (nDistanceFromLine<=u2mil(int(nWidth/2.0)))
					return 1;
				else
					return 0;
			}			
		}

		//point is within left and right of segment
		if(abs(1.0*YP-nY1)>nWidth/2.0)
			return 0;
		else
			return 1;
	}
	else
	{
		return 0;	//can't handle
	} 
	
}

//FUNCTION to go through all the selected signals on a PCB and put any signals with polygons and fillings
//into the segment tables
void GetSignalSegments(void)
{
	int n,i;
	string s;

	project.board(B)
	{
		n = 0;
		B.signals(S)
		{
			i = 0;
			while(sSelectedNets[i]!="")
			{
				s = sSelectedNets[i];
				if(S.name==s)
				{
					S.polygons(P)
					{
						
						P.fillings(C)
						{
							nXSegStart[n] = C.x1;
							nYSegStart[n] = C.y1;
							nXSegEnd[n] = C.x2;
							nYSegEnd[n] = C.y2;
							nSegLayers[n] = C.layer;
							sSegSignal[n] = s;
							nSegWidth[n] = C.width;
							n++;	
						}
					}
					
				}
				i++;
			}
		
		}
		nNumSegs = n;
	}
}

//Checks if a via position has a filling underneath it for at least two layers
string IsOnPolygonSignal(int XPos, int YPos)
{
	string s;
	int i,j;
	string sOnSignal;
	int nFirstLayer;
	int n;
	
	i = 0;
	sOnSignal = "";
		
	//output(path_scr[0]+'/'+"test.scr","a")
	//{

	while(i<nNumSegs)
	{
		if(IsOnSeg(nXSegStart[i],nYSegStart[i],nXSegEnd[i],nYSegEnd[i],XPos, YPos, nSegWidth[i]) && (nSegLayers[i] == 1 || nSegLayers[i] == 16) )
		{
			sOnSignal = sSegSignal[i];
			nFirstLayer = nSegLayers[i];
			j = i+1;
			//found first segment that has the via....need to see if there is one on the bottom side

			//printf("Point Coordinate: (%f %f), Wire Segment (%f %f %f %f) Width (%f) \n", u2mil(XPos), u2mil(YPos), u2mil(nXSegStart[i]), u2mil(nYSegStart[i]), u2mil(nXSegEnd[i]), u2mil(nYSegEnd[i]), u2mil(nSegWidth[i]));

			while(j<nNumSegs)
			{
				//we're looking through remaining segments
				if(sSegSignal[j]==sOnSignal)
				{
					//picking only the ones with this layer
					if(IsOnSeg(nXSegStart[j],nYSegStart[j],nXSegEnd[j],nYSegEnd[j],XPos, YPos, nSegWidth[j]))
					{
						//if via is on segment on another layer
						if(nSegLayers[j]!=nFirstLayer && (nSegLayers[j] == 1 || nSegLayers[j] == 16))
						{
							//Check if the via collides with anything
							if(CheckViaCollision(XPos, YPos))
							{
								return sOnSignal;
							}
						}
					}
				}
				j++;
			}

		}
		i++;
	}

	//}

	if (i==nNumSegs) sOnSignal = "";

	return sOnSignal;	
}

void addtopolygonlist(string s )
{
	int i;
	i = 0;
	while(sPolygonNets[i]!="")
	{
		if(sPolygonNets[i]==s) return;
		i++;
	}
	sPolygonNets[i] = s;
}

void removefrompolygonlist(string s)
{
	int i,j,k;
	i =0;
	k =0;
	while(sPolygonNets[i]!="")
	{
		if(k==0)
		{
			if(sPolygonNets[i]==s)
			{
				sPolygonNets[i] = sPolygonNets[i+1];
				k=1;
			}
		}
		else
			sPolygonNets[i] = sPolygonNets[i+1];
		i++;
	}
}

void addtoselectedlist(string s )
{
	int i;
	i = 0;
	while(sSelectedNets[i]!="")
	{
		if(sSelectedNets[i]==s) return;
		i++;
	}
	sSelectedNets[i] = s;
}

void removefromselectedlist(string s)
{
	int i,j,k;
	i =0;
	k =0;
	while(sSelectedNets[i]!="")
	{
		if(k==0)
		{
			if(sSelectedNets[i]==s)
			{
				sSelectedNets[i] = sSelectedNets[i+1];
				k=1;
			}
		}
		else
			sSelectedNets[i] = sSelectedNets[i+1];
		i++;
	}
}

//FUCNTION that Creates a grid of vias and then tests if the via has a top and bottom layer underneath it that belongs to the selected net
//list
//Two scripts are created, one named 'viapos.scr' and 'viaposundo.scr'. Note that the undo script mearly has the same number of undo
//statements as the viapos.scr script.....so should only be used immediately after a placement operation.
string placeVias(void)
{

	int nNumSegs=0;
	int nXVia[];
	int nYVia[];
	string script_name;
	string t;
	int n,i,nVias;
	int x,y;		//grid positions
	string sSignal;
	int nAddedVias;
	string scriptValue;
	string temp;

	//script_name=path_scr[0]+'/'+"viapos.scr";
	//output(script_name,"w")
	//{
		status("Placing Vias!");

		//setup via grid according to user settings
		n = 0;
		for(x=0;x<xsize;x++)
		{
			for(y=0;y<ysize;y++)
			{
				if((y % 2)==0)
				{
					nXVia[n] = nXOrigin+x*niViaSpacing+niViaSpacing*0.5; 
				}
				else
				{

					nXVia[n] = nXOrigin+x*niViaSpacing+niViaSpacing*1.0;
				}
				
				//Add vias "out of grid", by misplacing them by 1u, so we know that
				//these are automplaced vias and we can remove them
				nYVia[n] = nYOrigin+y*niViaSpacing + 1 + niViaSpacing*0.5;

				//sprintf(t,"//%d %d\r\n", nXVia[n], nYVia[n]);
				//printf(t);

				n++;
			}
		}
		

		status("Checking Vias!");
		
		sprintf(t,"CHANGE DRILL %f;\r\n", nViaDiameter);
		scriptValue += t; 

		//check if via on polgyon		
		nVias = n;
		nAddedVias = 0;
		for(n=0;n<nVias;n++)
		{
			sprintf(temp, "Progress %.1f %%", 1.0*n/nVias*100);
			status(temp);
			sSignal=IsOnPolygonSignal(nXVia[n], nYVia[n]);	//see if vias has a signal under two layers and return signal name
			if(sSignal!="")
			{
				//write a via of that signal to that position
				sprintf(t,"VIA '%s' Round (%f %f);\r\n", sSignal, pcbPosition(nXVia[n]), pcbPosition(nYVia[n]));
				scriptValue += t; 
				//printf(t);
				nAddedVias++;
			}
		}
		
	//}
	
	script_name = path_scr[0]+'/'+"viaposundo.scr";
	output(script_name,"w")
	{
		for(n=0;n<nAddedVias;n++)
		{
			printf("undo\r\n");
		}
	}
	return scriptValue;
}


string removeVias(void)
{

	string scriptValue;
	string t;

	project.board(B)
	{
		B.signals(S) 
		{
			S.vias(V) 
			{
				//sprintf(t, "%d %d", (V.x) % (niViaSpacing/2), (V.y) % (niViaSpacing/2));
				//dlgMessageBox(t);

				//Identify automatically placed vias
				if( (V.x % (niViaSpacing/2)) == 0 && 
				    (V.y % (niViaSpacing/2)) == 1)
				{
					sprintf(t,"RIPUP (%f %f);\r\n", pcbPosition(V.x), pcbPosition(V.y));
					scriptValue += t; 
				}

			}
		}
	}

	return scriptValue;
}


void show_dialog(void)
{
	int Result=1;
	string s;
	int Selected;
	int n;
	int SelectedNet=0;
	string scriptValue = "";

	GetDesignInfo();
	if(board)
	{
		while(Result!=0)
		{
			Result = dlgDialog("Via fill v2") 
			{

				
				dlgHBoxLayout {
					sprintf(s,"Via spacing(%s)",sPCBdim);
		  			dlgLabel(s);
            				dlgRealEdit(nViaSpacing);
					sprintf(s,"Via diameter (%s)",sPCBdim);
		  			dlgLabel(s);
					dlgRealEdit(nViaDiameter);
				};
				dlgHBoxLayout {
					sprintf(s,"Isolate around existing vias (%s)",sPCBdim);
		  			dlgLabel(s);
            				dlgRealEdit(nViaIsolate );
				};
				dlgHBoxLayout {
					dlgGroup("Available nets"){
						dlgListBox(sPolygonNets,SelectedNet);
					};
					dlgVBoxLayout {
						dlgPushButton("&Add") dlgAccept(3);
						dlgPushButton("&Remove") dlgAccept(4);

					}
					dlgGroup("Nets to fill"){
						dlgListBox(sSelectedNets,Selected);
					};
				};
				dlgHBoxLayout {
					dlgPushButton("Cancel") 		dlgReject(0);
					dlgPushButton("&Remove Vias") 	dlgAccept(6);
					dlgPushButton("&Place Vias") 		dlgAccept(5);
					
				}

			};

			niViaSpacing 	= internalPosition(nViaSpacing);
			niViaDiameter 	= internalPosition(nViaDiameter);
			niViaIsolate 	= internalPosition(nViaIsolate);

			if(Result==4)
			{
				//move from selected list to available list
				addtopolygonlist(sSelectedNets[Selected]);
				removefromselectedlist(sSelectedNets[Selected]);
			}
			else if(Result==3)
			{
				//move from available list to selected list
				addtoselectedlist(sPolygonNets[SelectedNet]);
				removefrompolygonlist(sPolygonNets[SelectedNet]);
			}
			else if(Result==5)
			{
				s = sSelectedNets[0];
				if (s!="")
				{
					GetSignalSegments();
					scriptValue = placeVias();
					//dlgMessageBox("Done! Check viapos.scr and viaposundo.scr in scripts folder");
					exit(scriptValue);
				}	
			}
			else if(Result==6)
			{	
				scriptValue = removeVias();
				exit(scriptValue);
				dlgMessageBox("Not implemented yet!");
			}
			else
			{
				Result = 0;
			}
		};
	};
}

show_dialog();
exit(1);