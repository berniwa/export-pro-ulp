/************************************************************/
/* HTLExportPro_Crop.ulp                                    */
/* - Beschneidet Monochrome BMP Images                      */
/************************************************************/
/* (c) Copyright 2009, Bernhard Wörndl-Aichriedler          */
/* xDevelop OG - Hardware Developer			*/
/* E-Mail: bwa@berniwa.com (bwa@xdevelop.at)                */
/* Homepage: www.berniwa.com (www.xdevelop.at)              */
/************************************************************/
/* Die Verwendung, das Kopieren bzw. die Weiterverbreitung  */
/* dieses ULP sind nur nach ausdrücklicher Erlaubnis des    */
/* Autors gestattet! 				*/
/************************************************************/
/* Letzte Änderung am 14.12.2009                            */
/* Version 1.0 (in Export 4)                              	*/
/************************************************************/
/* Letzte Änderung am 19.02.2010                            */
/* Version 1.2 (in ExportPro5)                            	*/
/* Nun auch zu Eagle 5.7 kompatibel, das die Bilder nun	*/
/* mit anderer Palette exportiert			*/
/************************************************************/


int BMP_bfOffBits = 10;
int BMP_biWidth 	= 18;
int BMP_biHeight	= 22;
int BMP_colorTableFirst = 0x36;

char bmpData[];
int bmpOffset = 0;
int bmpWidth = 0;
int bmpHeight = 0;
int bmpBlockSize = 0;

char bmpExtractBit(char value , int bit)
{
	return (((value) & (1 << (bit))) >> (bit));
}

char bmpGetPixel(int offset, int pixel)
{
	if(pixel < 0 || pixel > bmpWidth)
	{
		return 0;
	}
	else
	{
		char tmp = 0;
		tmp |= bmpExtractBit(bmpData[offset + (pixel/8)], 7 - (pixel%8));
		return tmp;
	}

}

int bmpReadInt(int offset)
{
	int value = 0;
			
	for(int i = 0; i < 4; i++) 
	{
		value |= bmpData[offset + i] << (i*8);
	}

	return value;	
}

void bmpWriteInt(int bmpInt)
{

	int value = 0;
		
	for(int i = 0; i < 4; i++) 
	{
		printf("%c", (bmpInt >> (8*i)) & 0x000000FF);
	}	
}

void bmpConvert(string ifilename)
{
	int bmpOffsetTop = 0, bmpOffsetLeft = -1, bmpOffsetRight = -1, bmpOffsetBottom = 0;
	int bmpOffsetTopDetected = 0, bmpOffsetBottomDetected = 0;
	int bmpZeroIsBlack = 0; 


	int nBytes = fileread(bmpData, ifilename);

  
  	/*
  		Read status information
  	*/
  	bmpOffset = bmpReadInt(BMP_bfOffBits);
  	bmpWidth = bmpReadInt(BMP_biWidth);
  	bmpHeight = bmpReadInt(BMP_biHeight);

	/*
		Check what color in the table is white and what is black
		Quick'n dirty
	*/
	bmpZeroIsBlack = (bmpData[BMP_colorTableFirst] == 0)?1:0;	

	/*
  		Calculate blocksize
  	*/
	bmpBlockSize = 4 * ( ( bmpWidth + 31 ) / 32 );


	string mstatus = "";
	sprintf(mstatus, "Cropping image: %s - Calculating cropping areas", ifilename);
	status(mstatus);

	int lastline_mask = (pow(2, (bmpWidth % 8)) - 1);
	int used_blocks = bmpWidth / 8;	

	/*
  		Walk thru - line by line
  	*/
  	for(int line = 0; line < bmpHeight; line++)
  	{
  		int offset = bmpOffset+line*bmpBlockSize;

		int bmpLineOffsetLeft = 0, bmpLineOffsetRight = 0;
		int bmpLineOffsetLeftDetected = 0, bmpLineOffsetRightDetected = 0;

  		for(int byte = 0; byte < bmpBlockSize; byte++)
  		{
			int dbyte = offset + byte;
			int is_black = bmpData[dbyte];
			if(bmpZeroIsBlack)
			{
			
				is_black = (~bmpData[dbyte]) > 0;
				if(byte == used_blocks)
				{
					is_black = (~(lastline_mask & bmpData[dbyte])) > 0;
				}
				else if(byte > used_blocks)
				{	
					is_black = 0;
				}
			}
	
  			if(!is_black)
			{
				if(bmpLineOffsetLeftDetected == 0)
				{
					bmpLineOffsetLeft = byte * 8;
				}
				if(bmpLineOffsetRightDetected == 0)
				{
					bmpLineOffsetRight = byte * 8;
					bmpLineOffsetRightDetected = 1;
				}				
			}

			if(is_black && bmpLineOffsetLeftDetected == 0)
			{
				bmpLineOffsetLeftDetected = 1;
			}
			if(is_black && bmpLineOffsetRightDetected == 1)
			{
				bmpLineOffsetRightDetected = 0;
			}
  		}

		if(bmpLineOffsetLeftDetected == 0)
		{

			if(bmpOffsetTopDetected == 0)
			{
				bmpOffsetTop = line;
			}
			if(bmpOffsetBottomDetected == 0)
			{
				bmpOffsetBottom = line;
				bmpOffsetBottomDetected = 1;
			}
		}
		else
		{
			if(bmpOffsetTopDetected == 0)
			{
				bmpOffsetTopDetected = 1;
			}
			if(bmpOffsetBottomDetected == 1)
			{
				bmpOffsetBottomDetected = 0;				
			}
			if(bmpOffsetLeft == -1 || bmpLineOffsetLeft < bmpOffsetLeft)
			{
				bmpOffsetLeft = bmpLineOffsetLeft;
			}
			if(bmpOffsetRight == -1 || bmpLineOffsetRight > bmpOffsetRight)
			{
				bmpOffsetRight = bmpLineOffsetRight;
			}
		}	
  	}




  	/*
  		Calculate new Information
  	*/
  	int bmpNewWidth = bmpOffsetRight - bmpOffsetLeft;
  	int bmpNewHeight = bmpOffsetBottom - bmpOffsetTop;

  	/*
  		Calculate blocksize
  	*/
  	int bmpNewBlockSize = 4 * ( ( bmpNewWidth + 31 ) / 32 );
	
	output(ifilename, "wb")
	{	
  		string mstatus = "";
  		sprintf(mstatus, "Cropping image: %s - Loading image information", ifilename);
  		status(mstatus);

  	
  		/*
  			Copy header
  		*/
  		for(int i = 0; i < bmpOffset; i++)
  		{
			if(i == BMP_biWidth)
			{
				//Write new width & height
				bmpWriteInt(bmpNewWidth);
				bmpWriteInt(bmpNewHeight);
				i+=7;	
			}
			else
			{
  				printf("%c", bmpData[i]);
			}	
  		}
  	
  		sprintf(mstatus, "Cropping image: %s - Copying image data", ifilename);
  		status(mstatus);
  
  		/*
  			Walk thru - line by line
  		*/
  		for(int line = bmpOffsetTop; line < bmpOffsetBottom; line++)
  		{
  			int offset = bmpOffset+line*bmpBlockSize;
  	
  			sprintf(mstatus, "Cropping image: %s - Finished %.0f%%", ifilename, (line*1.0/bmpHeight*100.0));
  			status(mstatus);
  	
  			for(int byte = 0; byte < bmpNewBlockSize; byte++)
  			{
				int dbyte = offset + (bmpOffsetLeft/8) + byte;
				printf("%c", bmpData[dbyte]);
			}	
  		}

	}

}


bmpConvert(argv[1]);
